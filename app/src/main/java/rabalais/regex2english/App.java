/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package rabalais.regex2english;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Queue;
import java.util.Stack;
import java.util.HashMap;


import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;

import rabalais.regex2english.generated.*;

public class App {
   
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) throws IOException{
        
        String input = "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=])(?!.*\\s).{8,16}$";
        // input = "src/main/resources/input.txt";

        processTree(input);

        // System.out.println("Key: \n----------------------------------------------------------------------------------------------------");
        // System.out.println("- Arrows (x) represents all of the (explicit) logical operators including quantifiers.");
        // System.out.println("          ∆");
        // System.out.println("- Single underline (x) represents an expression.\n                    ¯");
        // System.out.println("- Double underline (x) represents character classes.\n                    =");
        // System.out.println("- Triple underline (x) represents a token meaning letters or escape sequences.\n                    ≡");
        // System.out.println("- Quadruple underline (x) represents TBD\n                    ≣");
        // System.out.println("----------------------------------------------------------------------------------------------------");
      
        // System.out.println("\033[31mreminder to use ansi escape codes\033[0m");

        // treePrinter(tree, 1);

        //letters, charcter class,  groups, logical operators and meta sequences

        

    //    System.out.println("◀GROUP:1▶");


    }

     public static void getTerminals(ParseTree root, ArrayList<String> terminals){


        //letter or escape sequence or posix

        if(root != null){
            if(root instanceof TerminalNode){
                
                terminals.add(root.getText());

                return;
            }

            for(int i = 0; i < root.getChildCount(); i++){
               
                getTerminals(root.getChild(i), terminals);
                
            }
        }

     }

    public static void processTree(String input){


        CharStream inputStream = CharStreams.fromString(input);
        // CharStream input = CharStreams.fromFileName("src/main/resources/input.txt");
         
        regex2englishLexer lexer = new regex2englishLexer(inputStream);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        regex2englishParser parser = new regex2englishParser(tokens);

        ParseTree tree = parser.start();
        RegexVisitor visitor = new RegexVisitor();

        HashMap<String, ArrayList<String>> atoms = new HashMap<>();


        ArrayList<String> terminals = new ArrayList();
        getTerminals(tree, terminals);
        System.out.println(terminals.toString());

        // String treeString = tree.toStringTree(parser).replaceAll("exprHelper", "expr");

        // System.out.println("Pre-visitor:\n" + treeString);
        
        // visitor.visit(tree);

        // treeString = tree.toStringTree(parser).replaceAll("exprHelper", "expr");

        

    }


     public static void treePrinter(ParseTree root, int line){ // in-order traversal


        
        if(root != null){

            String payload = "empty";

            if(root instanceof RuleNode && root.getChildCount() == 1){

                ParseTree child = root.getChild(0);
              
                while(child != null && !(child instanceof TerminalNode) && root.getChildCount() == 1){
                    root = root.getChild(0);
                    // System.out.println("skip");
                }
                // System.out.println("Rule:" + ((RuleNode)root.getPayload()).getText());
            }


            if(root.getChildCount() > 0){
                payload = ((RuleContext)root.getPayload()).getText();
            }
            
            if(root.getParent() != null && root.getParent().getChildCount() == 1){
                // root = 

            }
            // System.out.print("'" + ((TerminalNode)root.getPayload()).getText() + "'  ");

            if(root.getChildCount() == 0){ 
                // return;
        
               

                payload = root.getText();

            }else{

                // payload = ((RuleContext)root.getPayload()).getText();

            }

            System.out.println("Line#" + line + "| '" + payload + "'");
            treePrinter(root.getChild(0), (root.getChild(0) != null) ? ++line: line);
            treePrinter(root.getChild(1), (root.getChild(1) != null) ? ++line: line);

        }

     }



    }

    /*
     * 
     * 
     * 4 categories: logical operators, expressions, character classes & tokens
     * 
     * logical operators includes:
     * - quantifier
     * - or
     * - 
     * 
     * 
     * expressions include:
     * - expr
     * - exprHelper (rename to expr)
     * - escapedToLiteralOutsideCharClass 
     * - quote
     * - zeroWidthAssertions
     * - inlineModifier
     * - captureGroup 
     * - group
     * - escapedFromLiteral 
     * - characterClass 
     * - backReference 
     * - boundaryMatcherStart 
     * - wordBoundary
     * - nonWordBoundary 
     * - inputStart
     * - endOfMatch 
     * - letter
     * - concatenation
     * - quantifier 
     * - boundaryMatcherEnd
     * - endOfInputExceptFinalTerminator
     *  - endOfOnput 
     * 
     * character classes include:
     * - CARET characterClassContent
     * - group
     * - escapedToLiteralInsideCharClass
     * - predefinedCharacterClass 
     * - posix 
     * - javalangCharacterClass 
     * - unicodeScriptClass
     * - (LETTER_RANGE | NUMBER_RANGE | ((LETTER | EXTRA_LETTER_ALLOWED_INSIDE) | CARET))+) 
     * - (characterClassContentHelper | <EOF>)
     * 
     * tokens include:
     * - letters
     * - escape sequences
     * 
     * 
     */


    

    
    // characterClassContentHelper: DOUBLE_AMPERSAND  (characterClass | characterClassContent) (characterClassContentHelper | <EOF>) 
    // | characterClass (characterClassContentHelper | <EOF>)
    // ;
    
    // escapedToLiteralInsideCharClass: BACKSLASH_ESCAPED
    // | RBRACKET_ESCAPED
    // | HYPHEN_ESCAPED
    // | LBRACKET_ESCAPED
    // ;
    
    // escapedToLiteralOutsideCharClass: LBRACKET_ESCAPED
    // | ASTERISK_ESCAPED
    // | PLUS_ESCAPED
    // | QMARK_ESCAPED
    // | LBRACE_ESCAPED
    // | DOT_ESCAPED
    // | LPAREN_ESCAPED
    // | RPAREN_ESCAPED
    // | CARET_ESCAPED
    // | DOLLAR_SIGN_ESCAPED
    // | PIPE_ESCAPED
    // | BACKSLASH_ESCAPED
    // ;
    
    // quote: LEFT_QUOTE expr RIGHT_QUOTE ;
    
    // zeroWidthAssertions: zeroWidthPositiveLookAhead
    // | zeroWidthNegativeLookAhead
    // | zeroWidthPositiveLookBehind
    // | zeroWidthNegativeLookBehind
    // ;
    
    // captureGroup: namedCaptureGroup
    // | nonCaptureGroup
    // | independentNonCapturingGroup
    // ;
    
    // // think of more things that aren't in character class but could go in group
    // group: LPAREN expr RPAREN
    // | LPAREN range RPAREN
    // ;
    
    // range: LETTER_RANGE
    // | NUMBER_RANGE
    // | RANGE_QUANTIFIER;
    
    // predefinedCharacterClass : WILDCARD
    // | DIGIT
    // | NON_DIGIT
    // | HORIZONTAL_WHITESPACE
    // | NON_HORIZONTAL_WHITESPACE
    // | WHITESPACE
    // | NON_WHITESPACE
    // | VERTICAL_WHITESPACE
    // | NON_VERTICAL_WHITESPACE
    // | WORD
    // | NON_WORD 
    // ;
    
    // characterClass: LBRACKET characterClassContent RBRACKET ;
    
    // backReference: N_TH_CAPTURE_GROUP
    // | NAMED_CAPTURE_GROUP_MATCH 
    // ;
    
    // boundaryMatcherStart: CARET expr ;
    
    // wordBoundary: WORD_BOUNDARY expr WORD_BOUNDARY ;
    
    // nonWordBoundary: NON_WORD_BOUNDARY expr NON_WORD_BOUNDARY;
    
    // inputStart: INPUT_START expr;
    
    // endOfMatch: END_OF_MATCH expr;
    
    // letter: LETTER+;
    
    // concatenation: expr;
    
    // quantifier: N_OCCURRANCES
    // | MAX_QUANTIFIER 
    // | MIN_QUANTIFIER
    // | RANGE_QUANTIFIER
    // | PLUS
    // | ASTERISK
    // | QMARK
    // ;
    
    // boundaryMatcherEnd: DOLLAR_SIGN ;
    
    // endOfInputExceptFinalTerminator: INPUT_END_INC_NEWLINE ;
    
    // endOfOnput: INPUT_END ;
    
    // or: PIPE expr ;
    
    // escapedFromLiteral : predefinedCharacterClass
    // | OCTAL_1 
    // | OCTAL_2 
    // | OCTAL_3 
    // | HEXA_2 
    // | HEXA_4 
    // | HEXA_6
    // | CARRIAGE_RETURN
    // | TAB 
    // | FORM_FEED
    // | ALERT
    // | ESC
    // | CARET
    // | DOLLAR_SIGN
    // | WORD_BOUNDARY
    // | NON_WORD_BOUNDARY
    // | INPUT_START
    // | END_OF_MATCH
    // | INPUT_END
    // | INPUT_END_INC_NEWLINE
    // | LINEBREAK_MATCHER
    // ;
    
    // // Inline Modifiers
    // inlineModifier: INLINEMODIFIER | (LOCAL_INLINE_MODIFIER_TEMPLATE expr RPAREN) ;
    
    // // Capture Groups
    // namedCaptureGroup : LPAREN '<?'NAMED_CAPTURE_GROUP_NAME'>' expr RPAREN;
    // nonCaptureGroup: LPAREN '?:' expr RPAREN;
    // independentNonCapturingGroup: LPAREN '?>' expr RPAREN;
    
    // // Look Aheads
    // zeroWidthPositiveLookAhead: LPAREN POSITIVE_LA expr RPAREN;
    // zeroWidthNegativeLookAhead: LPAREN NEGATIVE_LA expr RPAREN;
    // zeroWidthPositiveLookBehind: LPAREN POSITIVE_LB expr RPAREN;
    // zeroWidthNegativeLookBehind: LPAREN NEGATIVE_LB expr RPAREN;
    
    
    // // POSIX Character Classes (US-ASCII only)
    // posix :  '\\p{Lower}' # POSIX_LOWERCASE //[a-z] 
    // | '\\p{Upper}' # POSIX_UPPERCASE //[A-Z]
    // | '\\p{ASCII}' # POSIX_ASCII //[\x00-\x7F]
    // | '\\p{Alpha}' # POSIX_LETTERS // [a-zA-Z]
    // | '\\p{Digit}' # POSIX_DIGITS // [0-9]
    // | '\\p{Alnum}' # POSIX_ALPHANUMERIC // [a-zA-Z0-9]
    // | '\\p{Punct}' # POSIX_PUNCTUATION // [!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~]
    // | '\\p{Graph}' # POSIX_ALPHANUM_PUNCTUATION // Any alphanumeric or punctuation character [\p{Alnum}\p{Punct}]
    // | '\\p{Print}' # POSIX_WHITESPACE_OR_GLYPH // any glyph or whitespace
    // | '\\p{Blank}' # POSIX_SPACE_OR_TAB // space or tab: [ \t]
    // | '\\p{Cntrl}' # POSIX_CONTROL_CHARACTERS // control characters [\x00-\x1F\x7F]
    // | '\\p{XDigit}'# POSIX_X_DIGIT // [0-9a-fA-F]
    // | '\\p{Space}' # POSIX_WHITESPACE // whitespace character: [ \t\n\x0B\f\r]
    // ;
    
    // // java.lang.Character Classes 
    // javalangCharacterClass : '\\p{javaLowerCase}' # JAVALANG_CC_LOWERCASE // Equivalent to java.lang.Character.isLowerCase()
    // | '\\p{javaUpperCase}' # JAVALANG_CC_UPPERCASE	// Equivalent to java.lang.Character.isUpperCase()
    // | '\\p{javaWhitespace}' # JAVALANG_CC_WHITESPACE //Equivalent to java.lang.Character.isWhitespace()
    // | '\\p{javaMirrored}' # JAVALANG_CC_MIRRORED //Equivalent to java.lang.Character.isMirrored()
    // ;
    
    // //Classes for Unicode Scripts
    // unicodeScriptClass : '\\p{IsLatin}' # LATIN //A Latin script character (script)
    // | '\\p{InGreek}'# GREEK //A character in the Greek block (block)
    // |  '\\p{Lu}' # UPPERCASE //An uppercase letter (category)
    // | '\\p{IsAlphabetic}' # IS_ALPHABETIC  //An alphabetic character (binary property)
    // | '\\p{Sc}' # CURRENCY_SYMBOL //A currency symbol
    // | '\\P{InGreek}' # NOT_GREEK//Any character except one in the Greek block (negation)
    // | '[\\p{L}&&[^\\p{Lu}]]' # NOT_UPPERCASE//Any letter except an uppercase letter (subtraction)
    // ;
    
    // // Lexer:
    
    // WILDCARD: '.';
    // CARET : '^';
    // DIGIT: '\\d';
    // NON_DIGIT: '\\D';
    // HORIZONTAL_WHITESPACE: '\\h' ;
    // NON_HORIZONTAL_WHITESPACE: '\\H';
    // WHITESPACE: '\\s' ;
    // NON_WHITESPACE: '\\S' ;
    // VERTICAL_WHITESPACE: '\\v' ;
    // NON_VERTICAL_WHITESPACE: '\\V';
    // WORD: '\\w' ;
    // NON_WORD: '\\W' ;
    
    // // Quotes
    // LEFT_QUOTE: '\\Q';
    // RIGHT_QUOTE: '\\E';
    
    // // Ranges
    // LETTER_RANGE : [a-zA-Z]'-'[a-zA-Z];
    // NUMBER_RANGE : [0-9]'-'[0-9];
    
    // // Operators
    // DOUBLE_AMPERSAND : '&&' ;
    // PIPE : '|' ;
    
    // // Special Escaped Characters
    // PLUS_ESCAPED : '\\+' ;
    // LBRACE_ESCAPED : '\\{' ;
    // PIPE_ESCAPED : '\\|' ;
    // BACKSLASH_ESCAPED : '\\\\' ;
    // LPAREN_ESCAPED: '\\(' ;
    // RPAREN_ESCAPED: '\\)' ;
    // LBRACKET_ESCAPED: '\\]' ;
    // RBRACKET_ESCAPED: '\\[' ;
    // DOT_ESCAPED: '\\.' ;
    // CARET_ESCAPED: '\\^' ;
    // QMARK_ESCAPED: '\\?' ;
    // ASTERISK_ESCAPED : '\\*' ;
    // DOLLAR_SIGN_ESCAPED : '\\$';
    // HYPHEN_ESCAPED : '\\-' ;
    
    // // Quantifiers
    // N_OCCURRANCES : '{' [0-9] '}';
    // MAX_QUANTIFIER : '{,' [0-9]? '}';
    // MIN_QUANTIFIER : '{' [0-9]? ',}';
    // RANGE_QUANTIFIER : '{' [0-9]? ',' [0-9]? '}' ;
    // PLUS: '+';
    // ASTERISK: '*' ;
    // QMARK: '?' ;
    
    // // Brackets
    // LBRACKET : '[' ; 
    // RBRACKET : ']' ; 
    // LPAREN : '(' ;
    // RPAREN : ')';
    
    // // Characters
    // BACKSLASH : '\\';
    // OCTAL_1 : '\\0'[0-7];
    // OCTAL_2 : '\\0'[0-7][0-7];
    // OCTAL_3 : '\\0'[0-3][0-7][0-7];
    // HEXA_2 : '\\x'[a-fA-F0-9];
    // HEXA_4 : '\\u'[a-fA-F0-9][a-fA-F0-9][a-fA-F0-9][a-fA-F0-9];
    // HEXA_6 : 'x{U+'('10'|[0-9]|'00')?[a-fA-F0-9][a-fA-F0-9][a-fA-F0-9][a-fA-F0-9]'}';
    // CARRIAGE_RETURN : '\\r';
    // TAB : '\\t' ;
    // FORM_FEED : '\\f' ;
    // ALERT : '\\a' ;
    // ESC : '\\e' ;
    
    // //Lookaheads/behinds
    // POSITIVE_LA: '?=';
    // NEGATIVE_LA: '?!';
    // POSITIVE_LB: '?<=';
    // NEGATIVE_LB: '?<!';
    
    // // Boundary Matchers
    // DOLLAR_SIGN : '$';
    // WORD_BOUNDARY : '\\b';
    // NON_WORD_BOUNDARY : '\\B';
    // INPUT_START : '\\A';
    // END_OF_MATCH : '\\G';
    // INPUT_END : '\\z';
    // INPUT_END_INC_NEWLINE : '\\Z';
    
    // //Linebreak Matcher
    // LINEBREAK_MATCHER : '\\R' ;
    
    // // Letters
    // LETTER : [a-zA-Z0-9/!,#&];
    // EXTRA_LETTER_ALLOWED_INSIDE:  [|*\\?.$-]; //following: https://www.abareplace.com/blog/escape-regexp/
    
    // //Inline Modifier
    // /* 
    // - must be checked in the visitor whether modifiers are being repeatedly 
    // because ANTLR regex does not support lookaheads and back references so 
    // it cannot be verified here
    // - also check if it contains the minus sign which negates the toggle
    // */
    // INLINEMODIFIER: LPAREN QMARK [-?][imsx]+ RPAREN;
    // LOCAL_INLINE_MODIFIER_TEMPLATE: LPAREN QMARK [-]?[:][imsx]+ ;
    
    // // Back References
    // N_TH_CAPTURE_GROUP: '\\'[0-9]+ ;	// Whatever the nth capturing group matched
    // NAMED_CAPTURE_GROUP_MATCH: '\\k<'[a-zA-Z]+'>'; //	Whatever the named-capturing group "name" matched
    // NAMED_CAPTURE_GROUP_NAME : [a-zA-Z_];