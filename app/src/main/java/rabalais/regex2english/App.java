/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package rabalais.regex2english;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Queue;
import java.util.Stack;
import java.util.HashMap;
import java.util.Map;
import static java.util.Map.entry;    


import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;

import rabalais.regex2english.generated.*;

public class App {
   
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) throws IOException{
        
        String input = "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=])(?!.*\\s).{8,16}$";
        // input = "src/main/resources/input.txt";

        processTree(input);

        // System.out.println("Key: \n----------------------------------------------------------------------------------------------------");
        // System.out.println("- Arrows (x) represents all of the (explicit) logical operators including quantifiers.");
        // System.out.println("          ∆");
        // System.out.println("- Single underline (x) represents an expression.\n                    ¯");
        // System.out.println("- Double underline (x) represents character classes.\n                    =");
        // System.out.println("- Triple underline (x) represents a token meaning letters or escape sequences.\n                    ≡");
        // System.out.println("- Quadruple underline (x) represents TBD\n                    ≣");
        // System.out.println("----------------------------------------------------------------------------------------------------");
      
        // System.out.println("\033[31mreminder to use ansi escape codes\033[0m");

        // treePrinter(tree, 1);

        //letters, charcter class,  groups, logical operators and meta sequences

        

    //    System.out.println("◀GROUP:1▶");


    }

    public static String getCleanClassName(String dirty){

        Map<String, String> cleanClassNames = Map.ofEntries(
            entry("StartContext", "Start"),
            entry("ExprContext", "Expression"),
            entry("ExprHelperContext", "Expression"),
            entry("CharacterClassContentContext", "Character Class Context"),
            entry("CharacterClassContentHelperContext", "Character Class Context"),
            entry("EscapedToLiteralInsideCharClassContext", "Escape Sequence (inside character class)"),
            entry("EscapedToLiteralOutsideCharClassContext", "Escape Sequences (outside character class)"),
            entry("ZeroWidthAssertionsContext", "Zero Width Assertion"),
            entry("CaptureGroupContext", "Capture Group"),
            entry("GroupContext", "Group"),
            entry("RangeContext", "Range"),
            entry("PredefinedCharacterClassContext", "Predefined Character Class"),
            entry("CharacterClassContext", "Character Class"),
            entry("BackReferenceContext", "Back Reference"),
            entry("BoundaryMatcherStartContext", "Boundary Matcher Start"),
            entry("WordBoundaryContext", "Word Boundary"),
            entry("NonWordBoundaryContext", "Non Word Boundary"),
            entry("InputStartContext", "Input Start"),
            entry("EndOfMatchContext", "End Of Match"),
            entry("LetterContext", "Letter(s)"),
            entry("QuantifierContext", "Quantifier"),
            entry("BoundaryMatcherEndContext", "Boundary Matcher End"),
            entry("EndOfInputExceptFinalTerminatorContext", "End Of Input (except terminator)"),
            entry("EndOfInputContext", "End Of Input"),
            entry("OrContext", "Or"),
            entry("EscapedFromLiteralContext", "Escape Sequence"),
            entry("InlineModifierContext", "Inline Modifier"),
            entry("NamedCaptureGroupContext", "Named Capture Group")
            entry("NonCaptureGroupContext", "Non Capture Group")
            entry("IndependentNonCapturingGroupContext", "Independent Non Capturing Group")
            entry("ZeroWidthPositiveLookAheadContext", "Zero Width Positive Look Ahead")
            entry("ZeroWidthNegativeLookAheadContext", "Zero Width Negative Look Ahead")
            entry("ZeroWidthPositiveLookBehindContext", "Zero Width Positive Look Behind")
            entry("ZeroWidthNegativeLookBehindContext", "Zero Width Negative Look Behind")
            entry("PosixContext", "POSIX")
            entry("POSIX_LETTERSContext", "POSIX LETTERS")
            entry("POSIX_ALPHANUMERICContext", "POSIX ALPHANUMERIC")
            entry("POSIX_LOWERCASEContext", "POSIX Lowercase")
            entry("POSIX_WHITESPACE_OR_GLYPHContext", "POSIX Whitespace or Glyph")
            entry("POSIX_CONTROL_CHARACTERSContext", "POSIX Control Characters")
            entry("POSIX_ALPHANUM_PUNCTUATIONContext", "POSIX Alphanumeric or Punctuation")
            entry("POSIX_DIGITSContext", "POSIX Digits")
            entry("POSIX_WHITESPACEContext", "POSIX Whitespace")
            entry("POSIX_SPACE_OR_TABContext", "POSIX Space or Tab")
            entry("POSIX_ASCIIContext", "POSIX ASCII")
            entry("POSIX_UPPERCASEContext", "POSIX Uppercase")
            entry("POSIX_X_DIGITContext", "POSIX HEX")
            entry("POSIX_PUNCTUATIONContext", "POSIX Punctuation")
            entry("JavalangCharacterClassContext", "java.lang.Character")
            entry("JAVALANG_CC_LOWERCASEContext", "java.lang.Character Lowercase")
            entry("JAVALANG_CC_WHITESPACEContext", "java.lang.Character Whitespace")
            entry("JAVALANG_CC_UPPERCASEContext", "java.lang.Character Uppercase")
            entry("JAVALANG_CC_LOWERCASEContext", "java.lang.Character lowercase")
            entry("UnicodeScriptClassContext", "Unicode Script Class")
            entry("NOT_UPPERCASEContext", "Not Uppercase")
            entry("IS_ALPHABETICContext", "Is Alphabetic")
            entry("CURRENCY_SYMBOLContext", "Currency Symbol")
            entry("UPPERCASEContext", "Is Uppercase")
            entry("LATINContext", "Is Latin")
            entry("NOT_GREEKContext", "Not Greek")
            entry("GREEKContext", "Is Greek")
            entry("Extra_letters_allowed_inside_CCContext", "Letters")
        ); 
    
        String clean = cleanClassNames.get(dirty);

        return clean;
    }



     public static void getTerminals(ParseTree root, ArrayList<String> terminals){


        //letter or escape sequence or posix

        if(root != null){
            if(root instanceof TerminalNode){

                String type = root.getParent().getClass().getSimpleName();
                
                // terminals.add();
                // System.out.println("parent:"  + root.getParent().getText() + "root: " + root.getText());

                return;
            }

            for(int i = 0; i < root.getChildCount(); i++){
               
                getTerminals(root.getChild(i), terminals);
                
            }
        }

     }

    public static void processTree(String input){


        CharStream inputStream = CharStreams.fromString(input);
        // CharStream input = CharStreams.fromFileName("src/main/resources/input.txt");
         
        regex2englishLexer lexer = new regex2englishLexer(inputStream);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        regex2englishParser parser = new regex2englishParser(tokens);

        ParseTree tree = parser.start();
        RegexVisitor visitor = new RegexVisitor();

        HashMap<String, ArrayList<String>> atoms = new HashMap<>();


        ArrayList<String> terminals = new ArrayList();
        getTerminals(tree, terminals);
        System.out.println(terminals.toString());

        // String treeString = tree.toStringTree(parser).replaceAll("exprHelper", "expr");

        // System.out.println("Pre-visitor:\n" + treeString);
        
        // visitor.visit(tree);

        // treeString = tree.toStringTree(parser).replaceAll("exprHelper", "expr");

        

    }


     public static void treePrinter(ParseTree root, int line){ // in-order traversal
        
        if(root != null){

            String payload = "empty";

            if(root instanceof RuleNode && root.getChildCount() == 1){

                ParseTree child = root.getChild(0);
              
                while(child != null && !(child instanceof TerminalNode) && root.getChildCount() == 1){
                    root = root.getChild(0);
                    // System.out.println("skip");
                }
                // System.out.println("Rule:" + ((RuleNode)root.getPayload()).getText());
            }


            if(root.getChildCount() > 0){
                payload = ((RuleContext)root.getPayload()).getText();
            }
            
            if(root.getParent() != null && root.getParent().getChildCount() == 1){
                // root = 

            }
            // System.out.print("'" + ((TerminalNode)root.getPayload()).getText() + "'  ");

            if(root.getChildCount() == 0){ 
                // return;
        
               

                payload = root.getText();

            }else{

                // payload = ((RuleContext)root.getPayload()).getText();

            }

            System.out.println("Line#" + line + "| '" + payload + "'");
            treePrinter(root.getChild(0), (root.getChild(0) != null) ? ++line: line);
            treePrinter(root.getChild(1), (root.getChild(1) != null) ? ++line: line);

        }

     }



    }

    /*
     * 
     * 
     * 4 categories: logical operators, expressions, character classes & tokens
     * 
     * logical operators includes:
     * - quantifier
     * - or
     * - 
     * 
     * 
     * expressions include:
     * - expr
     * - exprHelper (rename to expr)
     * - escapedToLiteralOutsideCharClass 
     * - quote
     * - zeroWidthAssertions
     * - inlineModifier
     * - captureGroup 
     * - group
     * - escapedFromLiteral 
     * - characterClass 
     * - backReference 
     * - boundaryMatcherStart 
     * - wordBoundary
     * - nonWordBoundary 
     * - inputStart
     * - endOfMatch 
     * - letter
     * - concatenation
     * - quantifier 
     * - boundaryMatcherEnd
     * - endOfInputExceptFinalTerminator
     *  - endOfOnput 
     * 
     * character classes include:
     * - CARET characterClassContent
     * - group
     * - escapedToLiteralInsideCharClass
     * - predefinedCharacterClass 
     * - posix 
     * - javalangCharacterClass 
     * - unicodeScriptClass
     * - (LETTER_RANGE | NUMBER_RANGE | ((LETTER | EXTRA_LETTER_ALLOWED_INSIDE) | CARET))+) 
     * - (characterClassContentHelper | <EOF>)
     * 
     * tokens include:
     * - letters
     * - escape sequences
     * 
     * 
     */


    

    
    // characterClassContentHelper: DOUBLE_AMPERSAND  (characterClass | characterClassContent) (characterClassContentHelper | <EOF>) 
    // | characterClass (characterClassContentHelper | <EOF>)
    // ;
    
    // escapedToLiteralInsideCharClass: BACKSLASH_ESCAPED
    // | RBRACKET_ESCAPED
    // | HYPHEN_ESCAPED
    // | LBRACKET_ESCAPED
    // ;
    
    // escapedToLiteralOutsideCharClass: LBRACKET_ESCAPED
    // | ASTERISK_ESCAPED
    // | PLUS_ESCAPED
    // | QMARK_ESCAPED
    // | LBRACE_ESCAPED
    // | DOT_ESCAPED
    // | LPAREN_ESCAPED
    // | RPAREN_ESCAPED
    // | CARET_ESCAPED
    // | DOLLAR_SIGN_ESCAPED
    // | PIPE_ESCAPED
    // | BACKSLASH_ESCAPED
    // ;
    
    // quote: LEFT_QUOTE expr RIGHT_QUOTE ;
    
    // zeroWidthAssertions: zeroWidthPositiveLookAhead
    // | zeroWidthNegativeLookAhead
    // | zeroWidthPositiveLookBehind
    // | zeroWidthNegativeLookBehind
    // ;
    
    // captureGroup: namedCaptureGroup
    // | nonCaptureGroup
    // | independentNonCapturingGroup
    // ;
    
    // // think of more things that aren't in character class but could go in group
    // group: LPAREN expr RPAREN
    // | LPAREN range RPAREN
    // ;
    
    // range: LETTER_RANGE
    // | NUMBER_RANGE
    // | RANGE_QUANTIFIER;
    
    // predefinedCharacterClass : WILDCARD
    // | DIGIT
    // | NON_DIGIT
    // | HORIZONTAL_WHITESPACE
    // | NON_HORIZONTAL_WHITESPACE
    // | WHITESPACE
    // | NON_WHITESPACE
    // | VERTICAL_WHITESPACE
    // | NON_VERTICAL_WHITESPACE
    // | WORD
    // | NON_WORD 
    // ;
    
    // characterClass: LBRACKET characterClassContent RBRACKET ;
    
    // backReference: N_TH_CAPTURE_GROUP
    // | NAMED_CAPTURE_GROUP_MATCH 
    // ;
    
    // boundaryMatcherStart: CARET expr ;
    
    // wordBoundary: WORD_BOUNDARY expr WORD_BOUNDARY ;
    
    // nonWordBoundary: NON_WORD_BOUNDARY expr NON_WORD_BOUNDARY;
    
    // inputStart: INPUT_START expr;
    
    // endOfMatch: END_OF_MATCH expr;
    
    // letter: LETTER+;
    
    // concatenation: expr;
    
    // quantifier: N_OCCURRANCES
    // | MAX_QUANTIFIER 
    // | MIN_QUANTIFIER
    // | RANGE_QUANTIFIER
    // | PLUS
    // | ASTERISK
    // | QMARK
    // ;
    
    // boundaryMatcherEnd: DOLLAR_SIGN ;
    
    // endOfInputExceptFinalTerminator: INPUT_END_INC_NEWLINE ;
    
    // endOfOnput: INPUT_END ;
    
    // or: PIPE expr ;
    
    // escapedFromLiteral : predefinedCharacterClass
    // | OCTAL_1 
    // | OCTAL_2 
    // | OCTAL_3 
    // | HEXA_2 
    // | HEXA_4 
    // | HEXA_6
    // | CARRIAGE_RETURN
    // | TAB 
    // | FORM_FEED
    // | ALERT
    // | ESC
    // | CARET
    // | DOLLAR_SIGN
    // | WORD_BOUNDARY
    // | NON_WORD_BOUNDARY
    // | INPUT_START
    // | END_OF_MATCH
    // | INPUT_END
    // | INPUT_END_INC_NEWLINE
    // | LINEBREAK_MATCHER
    // ;
    
    // // Inline Modifiers
    // inlineModifier: INLINEMODIFIER | (LOCAL_INLINE_MODIFIER_TEMPLATE expr RPAREN) ;
    
    // // Capture Groups
    // namedCaptureGroup : LPAREN '<?'NAMED_CAPTURE_GROUP_NAME'>' expr RPAREN;
    // nonCaptureGroup: LPAREN '?:' expr RPAREN;
    // independentNonCapturingGroup: LPAREN '?>' expr RPAREN;
    
    // // Look Aheads
    // zeroWidthPositiveLookAhead: LPAREN POSITIVE_LA expr RPAREN;
    // zeroWidthNegativeLookAhead: LPAREN NEGATIVE_LA expr RPAREN;
    // zeroWidthPositiveLookBehind: LPAREN POSITIVE_LB expr RPAREN;
    // zeroWidthNegativeLookBehind: LPAREN NEGATIVE_LB expr RPAREN;
    
    
    // // POSIX Character Classes (US-ASCII only)
    // posix :  '\\p{Lower}' # POSIX_LOWERCASE //[a-z] 
    // | '\\p{Upper}' # POSIX_UPPERCASE //[A-Z]
    // | '\\p{ASCII}' # POSIX_ASCII //[\x00-\x7F]
    // | '\\p{Alpha}' # POSIX_LETTERS // [a-zA-Z]
    // | '\\p{Digit}' # POSIX_DIGITS // [0-9]
    // | '\\p{Alnum}' # POSIX_ALPHANUMERIC // [a-zA-Z0-9]
    // | '\\p{Punct}' # POSIX_PUNCTUATION // [!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~]
    // | '\\p{Graph}' # POSIX_ALPHANUM_PUNCTUATION // Any alphanumeric or punctuation character [\p{Alnum}\p{Punct}]
    // | '\\p{Print}' # POSIX_WHITESPACE_OR_GLYPH // any glyph or whitespace
    // | '\\p{Blank}' # POSIX_SPACE_OR_TAB // space or tab: [ \t]
    // | '\\p{Cntrl}' # POSIX_CONTROL_CHARACTERS // control characters [\x00-\x1F\x7F]
    // | '\\p{XDigit}'# POSIX_X_DIGIT // [0-9a-fA-F]
    // | '\\p{Space}' # POSIX_WHITESPACE // whitespace character: [ \t\n\x0B\f\r]
    // ;
    
    // // java.lang.Character Classes 
    // javalangCharacterClass : '\\p{javaLowerCase}' # JAVALANG_CC_LOWERCASE // Equivalent to java.lang.Character.isLowerCase()
    // | '\\p{javaUpperCase}' # JAVALANG_CC_UPPERCASE	// Equivalent to java.lang.Character.isUpperCase()
    // | '\\p{javaWhitespace}' # JAVALANG_CC_WHITESPACE //Equivalent to java.lang.Character.isWhitespace()
    // | '\\p{javaMirrored}' # JAVALANG_CC_MIRRORED //Equivalent to java.lang.Character.isMirrored()
    // ;
    
    // //Classes for Unicode Scripts
    // unicodeScriptClass : '\\p{IsLatin}' # LATIN //A Latin script character (script)
    // | '\\p{InGreek}'# GREEK //A character in the Greek block (block)
    // |  '\\p{Lu}' # UPPERCASE //An uppercase letter (category)
    // | '\\p{IsAlphabetic}' # IS_ALPHABETIC  //An alphabetic character (binary property)
    // | '\\p{Sc}' # CURRENCY_SYMBOL //A currency symbol
    // | '\\P{InGreek}' # NOT_GREEK//Any character except one in the Greek block (negation)
    // | '[\\p{L}&&[^\\p{Lu}]]' # NOT_UPPERCASE//Any letter except an uppercase letter (subtraction)
    // ;
    
    // // Lexer:
    
    // WILDCARD: '.';
    // CARET : '^';
    // DIGIT: '\\d';
    // NON_DIGIT: '\\D';
    // HORIZONTAL_WHITESPACE: '\\h' ;
    // NON_HORIZONTAL_WHITESPACE: '\\H';
    // WHITESPACE: '\\s' ;
    // NON_WHITESPACE: '\\S' ;
    // VERTICAL_WHITESPACE: '\\v' ;
    // NON_VERTICAL_WHITESPACE: '\\V';
    // WORD: '\\w' ;
    // NON_WORD: '\\W' ;
    
    // // Quotes
    // LEFT_QUOTE: '\\Q';
    // RIGHT_QUOTE: '\\E';
    
    // // Ranges
    // LETTER_RANGE : [a-zA-Z]'-'[a-zA-Z];
    // NUMBER_RANGE : [0-9]'-'[0-9];
    
    // // Operators
    // DOUBLE_AMPERSAND : '&&' ;
    // PIPE : '|' ;
    
    // // Special Escaped Characters
    // PLUS_ESCAPED : '\\+' ;
    // LBRACE_ESCAPED : '\\{' ;
    // PIPE_ESCAPED : '\\|' ;
    // BACKSLASH_ESCAPED : '\\\\' ;
    // LPAREN_ESCAPED: '\\(' ;
    // RPAREN_ESCAPED: '\\)' ;
    // LBRACKET_ESCAPED: '\\]' ;
    // RBRACKET_ESCAPED: '\\[' ;
    // DOT_ESCAPED: '\\.' ;
    // CARET_ESCAPED: '\\^' ;
    // QMARK_ESCAPED: '\\?' ;
    // ASTERISK_ESCAPED : '\\*' ;
    // DOLLAR_SIGN_ESCAPED : '\\$';
    // HYPHEN_ESCAPED : '\\-' ;
    
    // // Quantifiers
    // N_OCCURRANCES : '{' [0-9] '}';
    // MAX_QUANTIFIER : '{,' [0-9]? '}';
    // MIN_QUANTIFIER : '{' [0-9]? ',}';
    // RANGE_QUANTIFIER : '{' [0-9]? ',' [0-9]? '}' ;
    // PLUS: '+';
    // ASTERISK: '*' ;
    // QMARK: '?' ;
    
    // // Brackets
    // LBRACKET : '[' ; 
    // RBRACKET : ']' ; 
    // LPAREN : '(' ;
    // RPAREN : ')';
    
    // // Characters
    // BACKSLASH : '\\';
    // OCTAL_1 : '\\0'[0-7];
    // OCTAL_2 : '\\0'[0-7][0-7];
    // OCTAL_3 : '\\0'[0-3][0-7][0-7];
    // HEXA_2 : '\\x'[a-fA-F0-9];
    // HEXA_4 : '\\u'[a-fA-F0-9][a-fA-F0-9][a-fA-F0-9][a-fA-F0-9];
    // HEXA_6 : 'x{U+'('10'|[0-9]|'00')?[a-fA-F0-9][a-fA-F0-9][a-fA-F0-9][a-fA-F0-9]'}';
    // CARRIAGE_RETURN : '\\r';
    // TAB : '\\t' ;
    // FORM_FEED : '\\f' ;
    // ALERT : '\\a' ;
    // ESC : '\\e' ;
    
    // //Lookaheads/behinds
    // POSITIVE_LA: '?=';
    // NEGATIVE_LA: '?!';
    // POSITIVE_LB: '?<=';
    // NEGATIVE_LB: '?<!';
    
    // // Boundary Matchers
    // DOLLAR_SIGN : '$';
    // WORD_BOUNDARY : '\\b';
    // NON_WORD_BOUNDARY : '\\B';
    // INPUT_START : '\\A';
    // END_OF_MATCH : '\\G';
    // INPUT_END : '\\z';
    // INPUT_END_INC_NEWLINE : '\\Z';
    
    // //Linebreak Matcher
    // LINEBREAK_MATCHER : '\\R' ;
    
    // // Letters
    // LETTER : [a-zA-Z0-9/!,#&];
    // EXTRA_LETTER_ALLOWED_INSIDE:  [|*\\?.$-]; //following: https://www.abareplace.com/blog/escape-regexp/
    
    // //Inline Modifier
    // /* 
    // - must be checked in the visitor whether modifiers are being repeatedly 
    // because ANTLR regex does not support lookaheads and back references so 
    // it cannot be verified here
    // - also check if it contains the minus sign which negates the toggle
    // */
    // INLINEMODIFIER: LPAREN QMARK [-?][imsx]+ RPAREN;
    // LOCAL_INLINE_MODIFIER_TEMPLATE: LPAREN QMARK [-]?[:][imsx]+ ;
    
    // // Back References
    // N_TH_CAPTURE_GROUP: '\\'[0-9]+ ;	// Whatever the nth capturing group matched
    // NAMED_CAPTURE_GROUP_MATCH: '\\k<'[a-zA-Z]+'>'; //	Whatever the named-capturing group "name" matched
    // NAMED_CAPTURE_GROUP_NAME : [a-zA-Z_];